/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */

var rangesMerge=(()=>{var p=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames,m=Object.getOwnPropertySymbols;var y=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var $=(s,t,o)=>t in s?p(s,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):s[t]=o,u=(s,t)=>{for(var o in t||(t={}))y.call(t,o)&&$(s,o,t[o]);if(m)for(var o of m(t))R.call(t,o)&&$(s,o,t[o]);return s};var T=s=>p(s,"__esModule",{value:!0});var w=(s,t)=>{for(var o in t)p(s,o,{get:t[o],enumerable:!0})},E=(s,t,o,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of b(t))!y.call(s,i)&&(o||i!=="default")&&p(s,i,{get:()=>t[i],enumerable:!(r=h(t,i))||r.enumerable});return s};var j=(s=>(t,o)=>s&&s.get(t)||(o=E(T({}),t,1),s&&s.set(t,o),o))(typeof WeakMap!="undefined"?new WeakMap:0);var x={};w(x,{defaults:()=>c,rMerge:()=>O,version:()=>F});var D={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function d(s,t){if(!Array.isArray(s)||!s.length)return s;let o=u(u({},D),t),r,i;if(o.strictlyTwoElementsInRangeArrays&&!s.every((a,l)=>!Array.isArray(a)||a.length!==2?(r=l,i=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${r}th range (${JSON.stringify(s[r],null,4)}) has not two but ${i} elements!`);if(!s.every((a,l)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(r=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${r}th range (${JSON.stringify(s[r],null,4)}) does not consist of only natural numbers!`);let n=s.length**2,g=0;return Array.from(s).sort((a,l)=>(o.progressFn&&(g+=1,o.progressFn(Math.floor(g*100/n))),a[0]===l[0]?a[1]<l[1]?-1:a[1]>l[1]?1:0:a[0]<l[0]?-1:1))}var f="8.0.10";var F=f,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function O(s,t){function o(e){return e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(s)||!s.length)return null;let r;if(t)if(o(t)){if(r=u(u({},c),t),r.progressFn&&o(r.progressFn)&&!Object.keys(r.progressFn).length)r.progressFn=null;else if(r.progressFn&&typeof r.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof r.progressFn}", equal to ${JSON.stringify(r.progressFn,null,4)}`);if(![1,2,"1","2"].includes(r.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);if(typeof r.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof r.joinRangesThatTouchEdges}", equal to ${JSON.stringify(r.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else r=u({},c);let i=s.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),n,g,a;r.progressFn?n=d(i,{progressFn:e=>{a=Math.floor(e/5),a!==g&&(g=a,r.progressFn(a))}}):n=d(i);let l=n.length-1;for(let e=l;e>0;e--)r.progressFn&&(a=Math.floor((1-e/l)*78)+21,a!==g&&a>g&&(g=a,r.progressFn(a))),(n[e][0]<=n[e-1][0]||!r.joinRangesThatTouchEdges&&n[e][0]<n[e-1][1]||r.joinRangesThatTouchEdges&&n[e][0]<=n[e-1][1])&&(n[e-1][0]=Math.min(n[e][0],n[e-1][0]),n[e-1][1]=Math.max(n[e][1],n[e-1][1]),n[e][2]!==void 0&&(n[e-1][0]>=n[e][0]||n[e-1][1]<=n[e][1])&&n[e-1][2]!==null&&(n[e][2]===null&&n[e-1][2]!==null?n[e-1][2]=null:n[e-1][2]!=null?+r.mergeType==2&&n[e-1][0]===n[e][0]?n[e-1][2]=n[e][2]:n[e-1][2]+=n[e][2]:n[e-1][2]=n[e][2]),n.splice(e,1),e=n.length);return n.length?n:null}return j(x);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
